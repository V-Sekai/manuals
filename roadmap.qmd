---
title: "Roadmap"
format: 
  html:
    page-layout: full
---

```{python}
#| label: roadmap
#| echo: false
#| output: asis

import vote
import pandas as pd
import plotly.express as px
from itables import init_notebook_mode, show

init_notebook_mode(all_interactive=False)


# Load voting results
results = vote.run_election('./roadmap/votes', 1, "./roadmap/tasks.csv")
avg_table = results["avg_table"]

# Load all tasks (preserve Effort and other columns)
tasks_df = pd.read_csv("./roadmap/tasks.csv")
if "Priority" not in tasks_df.columns:
    tasks_df["Priority"] = 0
# Merge in Priority from avg_table (by Task, left join)
priority_df = avg_table[["Task", "Priority"]]
df = tasks_df.merge(priority_df, on="Task", how="left", suffixes=("", "_voted"))
# Use voted Priority if available, else fallback to original
df["Priority"] = df["Priority_voted"].fillna(df["Priority"])
df.drop(columns=["Priority_voted"], inplace=True)

# Ensure Effort is numeric, fill missing with 0, and filter out negative Effort
df["Effort"] = pd.to_numeric(df["Effort"], errors="coerce").fillna(0)
df = df[df["Effort"] >= 0]


# Filter out completed tasks (do not show in charts)
df = df[df['Completed_on'].isna()]
# Keep archived tasks renewable (they can be shown if not completed)
df = df.drop(columns=["Completed_on"], errors="ignore")

# Reorder columns
if "Created_on" in df.columns:
    df = df[["Category", "Task", "Priority", "Effort", "Notes", "Created_on"]]
else:
    df = df[["Category", "Task", "Priority", "Effort", "Notes"]]

# Compute Pareto frontier: for each latency, keep the task with the highest priority so far
df_sorted = df.sort_values(by="Latency", ascending=True)
pareto_tasks = []
max_priority = float('-inf')
for _, row in df_sorted.iterrows():
    if row["Priority"] >= max_priority:
        pareto_tasks.append(row["Task"])
        max_priority = row["Priority"]

# Highlight Pareto-optimal tasks
df["Pareto"] = df["Task"].isin(pareto_tasks)
df["Task_Display"] = df.apply(lambda r: f"{r['Task']} ðŸš¨" if r["Pareto"] else r["Task"], axis=1)



# Use Latency (age in days since Created_on) as x-axis, Effort as marker size
import numpy as np
from datetime import datetime
min_size = 10
max_size = 100
def compute_latency(row):
    try:
        if "Created_on" not in row or pd.isna(row["Created_on"]):
            return np.nan
        created = pd.to_datetime(row["Created_on"], errors="coerce")
        if pd.isna(created):
            return np.nan
        return (datetime.now() - created).days
    except Exception:
        return np.nan
df["Latency"] = df.apply(compute_latency, axis=1)
# Effort as marker size
effort_valid = df["Effort"].dropna()
if not effort_valid.empty:
    effort_norm = (df["Effort"] - effort_valid.min()) / (effort_valid.max() - effort_valid.min() + 1e-6)
    marker_sizes = min_size + (max_size - min_size) * (effort_norm ** 3)
    marker_sizes = marker_sizes.fillna(min_size)
else:
    marker_sizes = pd.Series([min_size] * len(df), index=df.index)
fig = px.scatter(
    df,
    x="Latency",
    y="Priority",
    color="Pareto",
    size=marker_sizes,
    hover_data=["Task_Display", "Category", "Notes", "Effort", "Latency", "Created_on"],
    title="Feature Roadmap: Priority vs Latency (Pareto Frontier, Circle Size = Effort)",
    labels={"Latency": "Age (days)", "Priority": "Priority (Higher = More Votes)", "Effort": "Effort (1-100 Scale)", "Created_on": "Created"}
)


# Add step line for Pareto frontier (now sorted by Latency)
pareto_points = df[df["Pareto"]].sort_values(by="Latency")
if len(pareto_points) > 1:
    fig.add_scatter(
        x=pareto_points["Latency"],
        y=pareto_points["Priority"],
        mode="lines",
        line=dict(dash="dot", width=2),
        name="Pareto Frontier"
    )


fig.show()

 # Mirrored chart: previously archived tasks (those with non-empty Archived_on, but not completed)
archived_df = pd.read_csv("./roadmap/tasks.csv")
archived_df = archived_df[(archived_df["Archived_on"].notna()) & (archived_df["Archived_on"] != "") & (archived_df["Completed_on"].isna())]
if not archived_df.empty:
    # Merge in Priority from avg_table (if available)
    if "Priority" not in archived_df.columns:
        archived_df["Priority"] = 0
    priority_df = avg_table[["Task", "Priority"]]
    archived_df = archived_df.merge(priority_df, on="Task", how="left", suffixes=("", "_voted"))
    archived_df["Priority"] = archived_df["Priority_voted"].fillna(archived_df["Priority"])
    archived_df.drop(columns=["Priority_voted"], inplace=True, errors="ignore")
    archived_df["Effort"] = pd.to_numeric(archived_df["Effort"], errors="coerce").fillna(0)
    archived_df = archived_df[archived_df["Effort"] >= 0]
    # Pareto for archived: for each latency, keep the task with the highest priority so far
    archived_sorted = archived_df.sort_values(by="Latency", ascending=True)
    pareto_archived = []
    max_priority_arch = float('-inf')
    for _, row in archived_sorted.iterrows():
        if row["Priority"] >= max_priority_arch:
            pareto_archived.append(row["Task"])
            max_priority_arch = row["Priority"]
    archived_df["Pareto"] = archived_df["Task"].isin(pareto_archived)
    archived_df["Task_Display"] = archived_df.apply(lambda r: f"{r['Task']} ðŸš¨" if r["Pareto"] else r["Task"], axis=1)
    # Compute Latency for archived tasks
    def compute_latency_arch(row):
        try:
            if "Created_on" not in row or pd.isna(row["Created_on"]):
                return np.nan
            created = pd.to_datetime(row["Created_on"], errors="coerce")
            if pd.isna(created):
                return np.nan
            return (datetime.now() - created).days
        except Exception:
            return np.nan
    archived_df["Latency"] = archived_df.apply(compute_latency_arch, axis=1)
    # Effort as marker size
    effort_valid_arch = archived_df["Effort"].dropna()
    if not effort_valid_arch.empty:
        effort_norm_arch = (archived_df["Effort"] - effort_valid_arch.min()) / (effort_valid_arch.max() - effort_valid_arch.min() + 1e-6)
        marker_sizes_arch = min_size + (max_size - min_size) * (effort_norm_arch ** 3)
        marker_sizes_arch = marker_sizes_arch.fillna(min_size)
    else:
        marker_sizes_arch = pd.Series([min_size] * len(archived_df), index=archived_df.index)
    fig_arch = px.scatter(
        archived_df,
        x="Latency",
        y="Priority",
        color="Pareto",
        size=marker_sizes_arch,
        hover_data=["Task_Display", "Category", "Notes", "Effort", "Latency", "Created_on"],
        title="Archived Tasks: Priority vs Latency (Pareto Frontier, Circle Size = Effort)",
        labels={"Latency": "Age (days)", "Priority": "Priority (Higher = More Votes)", "Effort": "Effort (1-100 Scale)", "Created_on": "Created"}
    )
    pareto_points_arch = archived_df[archived_df["Pareto"]].sort_values(by="Latency")
    if len(pareto_points_arch) > 1:
        fig_arch.add_scatter(
            x=pareto_points_arch["Latency"],
            y=pareto_points_arch["Priority"],
            mode="lines",
            line=dict(dash="dot", width=2),
            name="Pareto Frontier"
        )
    fig_arch.show()

print("""
## Archived Tasks

Archived tasks

<details>
<summary>Show archived tasks</summary>
""")

archived_tasks_df = vote.get_archived_tasks_table('./roadmap/tasks.csv')
archived_tasks_df["Notes"] = archived_tasks_df["Notes"].fillna("")
archived_tasks_df.reset_index(drop=True, inplace=True)

show(archived_tasks_df)

print("""
</details>
""")

print("""

## Raw Votes

<details>
<summary>Show raw votes table</summary>

Raw votes count

""")

votes_dict = vote.get_votes('./roadmap/votes')
votes_df = pd.DataFrame(votes_dict)
votes_df = votes_df.fillna(0)
show(votes_df, paging=False)

print("""
</details>
""")
```