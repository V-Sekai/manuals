---
title: "Roadmap"
format: 
  html:
    page-layout: full
---

```{python}
#| label: roadmap
#| echo: false
#| output: asis

import vote
import pandas as pd
import plotly.express as px
from itables import init_notebook_mode, show

init_notebook_mode(all_interactive=False)

# Load voting results
results = vote.run_election('./roadmap/votes', 1, './roadmap/tasks.csv')
avg_table = results['avg_table']

# Load all tasks (preserve Effort and other columns)
tasks_df = pd.read_csv('./roadmap/tasks.csv')
if 'Priority' not in tasks_df.columns:
    tasks_df['Priority'] = 0
# Merge in Priority from avg_table (by Task, left join)
priority_df = avg_table[['Task', 'Priority']]
df = tasks_df.merge(priority_df, on='Task', how='left', suffixes=('', '_voted'))
# Use voted Priority if available, else fallback to original
df['Priority'] = df['Priority_voted'].fillna(df['Priority'])
df.drop(columns=['Priority_voted'], inplace=True)

# Ensure Effort is numeric, fill missing with 0, and filter out negative Effort
df['Effort'] = pd.to_numeric(df['Effort'], errors='coerce').fillna(0)
df = df[df['Effort'] >= 0]

# Filter out completed and archived tasks (do not show in chart)
if 'Completed_on' in df.columns:
    df = df[df['Completed_on'].isna()]
if 'Archived_on' in df.columns:
    df = df[df['Archived_on'].isna() | (df['Archived_on'] == '')]
df = df.drop(columns=['Completed_on', 'Archived_on'], errors='ignore')

# Reorder columns
if 'Created_on' in df.columns:
    df = df[['Category', 'Task', 'Priority', 'Effort', 'Notes', 'Created_on']]
else:
    df = df[['Category', 'Task', 'Priority', 'Effort', 'Notes']]

# Use Latency (age in days since Created_on) as x-axis, Effort as marker size
import numpy as np
from datetime import datetime
min_size = 10
max_size = 100
def compute_latency(row):
    try:
        if 'Created_on' not in row or pd.isna(row['Created_on']):
            return np.nan
        created = pd.to_datetime(row['Created_on'], errors='coerce')
        if pd.isna(created):
            return np.nan
        return (datetime.now() - created).days
    except Exception:
        return np.nan
df['Latency'] = df.apply(compute_latency, axis=1)

# Compute Pareto frontier: for each latency, keep the task with the highest priority so far
df_sorted = df.sort_values(by="Latency", ascending=True)
pareto_tasks = []
max_priority = float('-inf')
for _, row in df_sorted.iterrows():
    if row["Priority"] >= max_priority:
        pareto_tasks.append(row["Task"])
        max_priority = row["Priority"]
# Highlight Pareto-optimal tasks
df["Pareto"] = df["Task"].isin(pareto_tasks)
df["Task_Display"] = df.apply(lambda r: f"{r['Task']} ðŸš¨" if r["Pareto"] else r["Task"], axis=1)

# Compute Pareto for Effort vs Priority
df_sorted_ep = df.sort_values(by="Effort", ascending=True)
pareto_tasks_ep = []
max_priority_ep = float('-inf')
for _, row in df_sorted_ep.iterrows():
    if row["Priority"] >= max_priority_ep:
        pareto_tasks_ep.append(row["Task"])
        max_priority_ep = row["Priority"]
df["Pareto_EP"] = df["Task"].isin(pareto_tasks_ep)

# Compute Pareto for Effort vs Latency
df_sorted_el = df.sort_values(by="Effort", ascending=True)
pareto_tasks_el = []
min_latency_el = float('inf')
for _, row in df_sorted_el.iterrows():
    if row["Latency"] <= min_latency_el:
        pareto_tasks_el.append(row["Task"])
        min_latency_el = row["Latency"]
df["Pareto_EL"] = df["Task"].isin(pareto_tasks_el)

df['Pareto_label'] = df['Pareto'].map({True: 'Pareto Optimal', False: 'Dominated'})
df['Pareto_EP_label'] = df['Pareto_EP'].map({True: 'Pareto Optimal', False: 'Dominated'})
df['Pareto_EL_label'] = df['Pareto_EL'].map({True: 'Pareto Optimal', False: 'Dominated'})

# Calculate raw vote count for each task
votes_dict = vote.get_votes('./roadmap/votes')
vote_counts = {}
for voter, ballot in votes_dict.items():
    for task, vote_val in ballot.items():
        vote_counts[task] = vote_counts.get(task, 0) + vote_val

total_votes = sum(vote_counts.values()) if vote_counts else 1
# Add normalized vote count to dataframe
# If a task has no votes, set to 0
df['RawVoteCount'] = df['Task'].map(lambda t: vote_counts.get(t, 0))
df['NormVoteCount'] = df['RawVoteCount'] / total_votes


# Call the chart functions
# Effort as marker size
effort_valid = df["Effort"].dropna()
if not effort_valid.empty:
    effort_norm = (df["Effort"] - effort_valid.min()) / (effort_valid.max() - effort_valid.min() + 1e-6)
    marker_sizes = min_size + (max_size - min_size) * (effort_norm ** 3)
    marker_sizes = marker_sizes.fillna(min_size)
else:
    marker_sizes = pd.Series([min_size] * len(df), index=df.index)
fig = px.scatter(
    df,
    x="Latency",
    y="Priority",
    color="Pareto_label",
    size=marker_sizes,
    hover_data=["Task", "Category", "Notes", "Effort", "Latency", "Created_on"],
    title="Feature Roadmap: Priority vs Latency (Pareto Frontier, Circle Size = Effort)",
    labels={"Latency": "Age (days)", "Priority": "Priority (Higher = More Votes)", "Pareto_label": "Optimality", "Effort": "Effort (1-100 Scale)", "Created_on": "Created"},
    color_discrete_map={"Pareto Optimal": "#F4A261", "Dominated": "#6C757D"}
)


# Add step line for Pareto frontier (now sorted by Latency)
pareto_points = df[df["Pareto"]].sort_values(by="Latency")
if len(pareto_points) > 1:
    fig.add_scatter(
        x=pareto_points["Latency"],
        y=pareto_points["Priority"],
        mode="lines",
        line=dict(dash="dot", width=2),
        name="Pareto Frontier"
    )

fig.update_layout(plot_bgcolor='white')
fig.show()

fig_ep = px.scatter(
    df,
    x="Effort",
    y="Priority",
    color="Pareto_EP_label",
    size=marker_sizes,
    hover_data=["Task", "Category", "Notes", "Effort", "Priority", "Latency", "Created_on"],
    title="Feature Roadmap: Effort vs Priority (Pareto Frontier, Circle Size = Effort)",
    labels={"Effort": "Effort (1-100 Scale, lower is better)", "Priority": "Priority", "Pareto_EP_label": "Optimality", "Latency": "Age (days)", "Created_on": "Created"},
    color_discrete_map={"Pareto Optimal": "#F4A261", "Dominated": "#6C757D"}
)

pareto_points_ep = df[df["Pareto_EP"]].sort_values(by="Effort")
if len(pareto_points_ep) > 1:
    fig_ep.add_scatter(
        x=pareto_points_ep["Effort"],
        y=pareto_points_ep["Priority"],
        mode="lines",
        line=dict(dash="dot", width=2),
        name="Pareto Frontier"
    )

fig_ep.update_layout(plot_bgcolor='white')
fig_ep.show()

fig_el = px.scatter(
    df,
    x="Effort",
    y="Latency",
    color="Pareto_EL_label",
    size=marker_sizes,
    hover_data=["Task", "Category", "Notes", "Effort", "Priority", "Latency", "Created_on"],
    title="Feature Roadmap: Effort vs Latency (Pareto Frontier, Circle Size = Effort)",
    labels={"Effort": "Effort (1-100 Scale, lower is better)", "Latency": "Age (days)", "Pareto_EL_label": "Optimality", "Priority": "Priority", "Created_on": "Created"},
    color_discrete_map={"Pareto Optimal": "#F4A261", "Dominated": "#6C757D"}
)

fig_el.update_yaxes(autorange="reversed")

pareto_points_el = df[df["Pareto_EL"]].sort_values(by="Effort")
if len(pareto_points_el) > 1:
    fig_el.add_scatter(
        x=pareto_points_el["Effort"],
        y=pareto_points_el["Latency"],
        mode="lines",
        line=dict(dash="dot", width=2),
        name="Pareto Frontier"
    )

fig_el.update_layout(plot_bgcolor='white')
fig_el.show()

print("""

## How to Interpret the Roadmap Charts

**Chart 1: Priority vs Latency**
- **X-axis (Latency):** Age of the task in days (higher means older).
- **Y-axis (Priority):** Importance or value to the project (higher is better).
- **Pareto Frontier:** Dotted line shows the optimal trade-off between priority and age.
- **Interpretation:** Top-left tasks are high-priority and recentâ€”consider addressing these soon.

**Chart 2: Effort vs Priority**
- **X-axis (Effort):** Estimated work required (lower is better).
- **Y-axis (Priority):** Importance or value to the project (higher is better).
- **Pareto Frontier:** Dotted line shows the optimal trade-off between effort and priority.
- **Interpretation:** Tasks near the top-left are "quick wins" (high value, low effort). Tasks on the Pareto line are optimal trade-offs.

**Chart 3: Effort vs Latency**
- **X-axis (Effort):** Estimated work required (lower is better).
- **Y-axis (Latency):** Age of the task in days (higher means older).
- **Pareto Frontier:** Dotted line shows the optimal trade-off between effort and age.
- **Interpretation:** Top-left tasks are easy to do and recentâ€”these are good candidates for quick progress.

Use these charts to balance quick wins, urgent priorities, and neglected tasks for effective game project planning.

## Archived Tasks

Archived tasks

<details>
<summary>Show archived tasks</summary>
""")

archived_tasks_df = vote.get_archived_tasks_table('./roadmap/tasks.csv')
archived_tasks_df['Notes'] = archived_tasks_df['Notes'].fillna("")
archived_tasks_df.reset_index(drop=True, inplace=True)

show(archived_tasks_df)

print("""
</details>
""")

print("""

## Raw Votes

<details>
<summary>Show raw votes table</summary>

Raw votes count
""")

votes_dict = vote.get_votes('./roadmap/votes')
votes_df = pd.DataFrame(votes_dict)
votes_df = votes_df.fillna(0)
show(votes_df, paging=False)

print("""
</details>
""")
```